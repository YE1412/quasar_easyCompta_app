import { W as WebPlugin } from "./index.js";
const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    const base64StringWithoutTags = base64String.substr(base64String.indexOf(",") + 1);
    resolve(base64StringWithoutTags);
  };
  reader.onerror = (error) => reject(error);
  reader.readAsDataURL(blob);
});
const encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
const setCookie = (key, value, options = {}) => {
  const encodedKey = encode(key);
  const encodedValue = encode(value);
  const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
  const path = (options.path || "/").replace("path=", "");
  document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path}`;
};
const getCookies = () => {
  const output = [];
  const map = {};
  if (!document.cookie) {
    return output;
  }
  const cookies = document.cookie.split(";") || [];
  for (const cookie of cookies) {
    let [k, v] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
    k = decode(k).trim();
    v = decode(v).trim();
    map[k] = v;
  }
  const entries = Object.entries(map);
  for (const [key, value] of entries) {
    output.push({
      key,
      value
    });
  }
  return output;
};
const getCookie = (key) => {
  const cookies = getCookies();
  for (const cookie of cookies) {
    if (cookie.key === key) {
      return cookie;
    }
  }
  return {
    key,
    value: ""
  };
};
const deleteCookie = (key) => {
  document.cookie = `${key}=; Max-Age=0`;
};
const clearCookies = () => {
  const cookies = document.cookie.split(";") || [];
  for (const cookie of cookies) {
    document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);
  }
};
const normalizeHttpHeaders = (headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key, index) => {
    acc[key] = headers[originalKeys[index]];
    return acc;
  }, {});
  return normalized;
};
const buildUrlParams = (params, shouldEncode = true) => {
  if (!params)
    return null;
  const output = Object.entries(params).reduce((accumulator, entry) => {
    const [key, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += `${key}=${encodedValue}&`;
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = `${key}=${encodedValue}`;
    }
    return `${accumulator}&${item}`;
  }, "");
  return output.substr(1);
};
const buildRequestInit = (options, extra = {}) => {
  const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders(options.headers);
  const type = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output.body = options.data;
  } else if (type.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.data || {})) {
      params.set(key, value);
    }
    output.body = params.toString();
  } else if (type.includes("multipart/form-data")) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key) => {
        form.append(key, value);
      });
    } else {
      for (let key of Object.keys(options.data)) {
        form.append(key, options.data[key]);
      }
    }
    output.body = form;
    const headers2 = new Headers(output.headers);
    headers2.delete("content-type");
    output.headers = headers2;
  } else if (type.includes("application/json") || typeof options.data === "object") {
    output.body = JSON.stringify(options.data);
  }
  return output;
};
const request = async (options) => {
  const requestInit = buildRequestInit(options, options.webFetchExtra);
  const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
  const url = urlParams ? `${options.url}?${urlParams}` : options.url;
  const response = await fetch(url, requestInit);
  const contentType = response.headers.get("content-type") || "";
  let { responseType = "text" } = response.ok ? options : {};
  if (contentType.includes("application/json")) {
    responseType = "json";
  }
  let data;
  switch (responseType) {
    case "arraybuffer":
    case "blob":
      const blob = await response.blob();
      data = await readBlobAsBase64(blob);
      break;
    case "json":
      data = await response.json();
      break;
    case "document":
    case "text":
    default:
      data = await response.text();
  }
  const headers = {};
  response.headers.forEach((value, key) => {
    headers[key] = value;
  });
  return {
    data,
    headers,
    status: response.status,
    url: response.url
  };
};
const get = async (options) => request(Object.assign(Object.assign({}, options), { method: "GET" }));
const post = async (options) => request(Object.assign(Object.assign({}, options), { method: "POST" }));
const put = async (options) => request(Object.assign(Object.assign({}, options), { method: "PUT" }));
const patch = async (options) => request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
const del = async (options) => request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
class HttpWeb extends WebPlugin {
  constructor() {
    super();
    this.request = async (options) => request(options);
    this.get = async (options) => get(options);
    this.post = async (options) => post(options);
    this.put = async (options) => put(options);
    this.patch = async (options) => patch(options);
    this.del = async (options) => del(options);
    this.getCookiesMap = async (options) => {
      const cookies = getCookies();
      const output = {};
      for (const cookie of cookies) {
        output[cookie.key] = cookie.value;
      }
      return output;
    };
    this.getCookies = async (options) => {
      const cookies = getCookies();
      return { cookies };
    };
    this.setCookie = async (options) => {
      const { key, value, expires = "", path = "" } = options;
      setCookie(key, value, { expires, path });
    };
    this.getCookie = async (options) => getCookie(options.key);
    this.deleteCookie = async (options) => deleteCookie(options.key);
    this.clearCookies = async (options) => clearCookies();
    this.clearAllCookies = async () => clearCookies();
    this.uploadFile = async (options) => {
      const formData = new FormData();
      formData.append(options.name, options.blob || "undefined");
      const fetchOptions = Object.assign(Object.assign({}, options), { body: formData, method: "POST" });
      return this.post(fetchOptions);
    };
    this.downloadFile = async (options) => {
      const requestInit = buildRequestInit(options, options.webFetchExtra);
      const response = await fetch(options.url, requestInit);
      let blob;
      if (!(options === null || options === void 0 ? void 0 : options.progress))
        blob = await response.blob();
      else if (!(response === null || response === void 0 ? void 0 : response.body))
        blob = new Blob();
      else {
        const reader = response.body.getReader();
        let bytes = 0;
        let chunks = [];
        const contentType = response.headers.get("content-type");
        const contentLength = parseInt(response.headers.get("content-length") || "0", 10);
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          chunks.push(value);
          bytes += (value === null || value === void 0 ? void 0 : value.length) || 0;
          const status = {
            type: "DOWNLOAD",
            url: options.url,
            bytes,
            contentLength
          };
          this.notifyListeners("progress", status);
        }
        let allChunks = new Uint8Array(bytes);
        let position = 0;
        for (const chunk of chunks) {
          if (typeof chunk === "undefined")
            continue;
          allChunks.set(chunk, position);
          position += chunk.length;
        }
        blob = new Blob([allChunks.buffer], { type: contentType || void 0 });
      }
      return {
        blob
      };
    };
  }
}
export { HttpWeb };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViMi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vbm9kZV9tb2R1bGVzL0BjYXBhY2l0b3ItY29tbXVuaXR5L2h0dHAvZGlzdC9lc20vdXRpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci1jb21tdW5pdHkvaHR0cC9kaXN0L2VzbS9jb29raWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci1jb21tdW5pdHkvaHR0cC9kaXN0L2VzbS9yZXF1ZXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BjYXBhY2l0b3ItY29tbXVuaXR5L2h0dHAvZGlzdC9lc20vd2ViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhZCBpbiBhIEJsb2IgdmFsdWUgYW5kIHJldHVybiBpdCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAqIEBwYXJhbSBibG9iIFRoZSBibG9iIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBiYXNlNjQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQmxvYkFzQmFzZTY0ID0gYXN5bmMgKGJsb2IpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2U2NFN0cmluZyA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgIGNvbnN0IGJhc2U2NFN0cmluZ1dpdGhvdXRUYWdzID0gYmFzZTY0U3RyaW5nLnN1YnN0cihiYXNlNjRTdHJpbmcuaW5kZXhPZignLCcpICsgMSk7IC8vIHJlbW92ZSBwcmVmaXggXCJkYXRhOmFwcGxpY2F0aW9uL3BkZjtiYXNlNjQsXCJcbiAgICAgICAgcmVzb2x2ZShiYXNlNjRTdHJpbmdXaXRob3V0VGFncyk7XG4gICAgfTtcbiAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbn0pO1xuLyoqXG4gKiBTYWZlbHkgd2ViIGVuY29kZSBhIHN0cmluZyB2YWx1ZSAoaW5zcGlyZWQgYnkganMtY29va2llKVxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHZhbHVlIHRvIGVuY29kZVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKHN0cikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgICAucmVwbGFjZSgvJSgyWzM0NkJdfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpXG4gICAgLnJlcGxhY2UoL1soKV0vZywgZXNjYXBlKTtcbi8qKlxuICogU2FmZWx5IHdlYiBkZWNvZGUgYSBzdHJpbmcgdmFsdWUgKGluc3BpcmVkIGJ5IGpzLWNvb2tpZSlcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB2YWx1ZSB0byBkZWNvZGVcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oJVtcXGRBLUZdezJ9KSsvZ2ksIGRlY29kZVVSSUNvbXBvbmVudCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gJy4vdXRpbHMnO1xuLyoqXG4gKiBTZXQgYSBjb29raWVcbiAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldENvb2tpZSA9IChrZXksIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBTYWZlbHkgRW5jb2RlZCBLZXkvVmFsdWVcbiAgICBjb25zdCBlbmNvZGVkS2V5ID0gZW5jb2RlKGtleSk7XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlID0gZW5jb2RlKHZhbHVlKTtcbiAgICAvLyBDbGVhbiAmIHNhbml0aXplIG9wdGlvbnNcbiAgICBjb25zdCBleHBpcmVzID0gYDsgZXhwaXJlcz0keyhvcHRpb25zLmV4cGlyZXMgfHwgJycpLnJlcGxhY2UoJ2V4cGlyZXM9JywgJycpfWA7IC8vIERlZmF1bHQgaXMgXCI7IGV4cGlyZXM9XCJcbiAgICBjb25zdCBwYXRoID0gKG9wdGlvbnMucGF0aCB8fCAnLycpLnJlcGxhY2UoJ3BhdGg9JywgJycpOyAvLyBEZWZhdWx0IGlzIFwicGF0aD0vXCJcbiAgICBkb2N1bWVudC5jb29raWUgPSBgJHtlbmNvZGVkS2V5fT0ke2VuY29kZWRWYWx1ZSB8fCAnJ30ke2V4cGlyZXN9OyBwYXRoPSR7cGF0aH1gO1xufTtcbi8qKlxuICogR2V0cyBhbGwgSHR0cENvb2tpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldENvb2tpZXMgPSAoKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgaWYgKCFkb2N1bWVudC5jb29raWUpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpIHx8IFtdO1xuICAgIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBmaXJzdCBcIj1cIiB3aXRoIENBUF9DT09LSUUgdG8gcHJldmVudCBzcGxpdHRpbmcgb24gYWRkaXRpb25hbCBcIj1cIlxuICAgICAgICBsZXQgW2ssIHZdID0gY29va2llLnJlcGxhY2UoLz0vLCAnQ0FQX0NPT0tJRScpLnNwbGl0KCdDQVBfQ09PS0lFJyk7XG4gICAgICAgIGsgPSBkZWNvZGUoaykudHJpbSgpO1xuICAgICAgICB2ID0gZGVjb2RlKHYpLnRyaW0oKTtcbiAgICAgICAgbWFwW2tdID0gdjtcbiAgICB9XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLyoqXG4gKiBHZXRzIGEgc2luZ2xlIEh0dHBDb29raWUgZ2l2ZW4gYSBrZXlcbiAqL1xuZXhwb3J0IGNvbnN0IGdldENvb2tpZSA9IChrZXkpID0+IHtcbiAgICBjb25zdCBjb29raWVzID0gZ2V0Q29va2llcygpO1xuICAgIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgaWYgKGNvb2tpZS5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlOiAnJyxcbiAgICB9O1xufTtcbi8qKlxuICogRGVsZXRlcyBhIGNvb2tpZSBnaXZlbiBhIGtleVxuICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBjb29raWUgdG8gZGVsZXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVDb29raWUgPSAoa2V5KSA9PiB7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7a2V5fT07IE1heC1BZ2U9MGA7XG59O1xuLyoqXG4gKiBDbGVhcnMgb3V0IGNvb2tpZXMgYnkgc2V0dGluZyB0aGVtIHRvIGV4cGlyZSBpbW1lZGlhdGVseVxuICovXG5leHBvcnQgY29uc3QgY2xlYXJDb29raWVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBjb29raWVzKSB7XG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVxuICAgICAgICAgICAgLnJlcGxhY2UoL14gKy8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz0uKi8sIGA9O2V4cGlyZXM9JHtuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKCl9O3BhdGg9L2ApO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb29raWUuanMubWFwIiwiaW1wb3J0IHsgcmVhZEJsb2JBc0Jhc2U2NCB9IGZyb20gJy4vdXRpbHMnO1xuLyoqXG4gKiBOb3JtYWxpemUgYW4gSHR0cEhlYWRlcnMgbWFwIGJ5IGxvd2VyY2FzaW5nIGFsbCBvZiB0aGUgdmFsdWVzXG4gKiBAcGFyYW0gaGVhZGVycyBUaGUgSHR0cEhlYWRlcnMgb2JqZWN0IHRvIG5vcm1hbGl6ZVxuICovXG5jb25zdCBub3JtYWxpemVIdHRwSGVhZGVycyA9IChoZWFkZXJzID0ge30pID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICBjb25zdCBsb3dlcmVkS2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLm1hcChrID0+IGsudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGxvd2VyZWRLZXlzLnJlZHVjZSgoYWNjLCBrZXksIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY1trZXldID0gaGVhZGVyc1tvcmlnaW5hbEtleXNbaW5kZXhdXTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuLyoqXG4gKiBCdWlsZHMgYSBzdHJpbmcgb2YgdXJsIHBhcmFtZXRlcnMgdGhhdFxuICogQHBhcmFtIHBhcmFtcyBBIG1hcCBvZiB1cmwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHNob3VsZEVuY29kZSB0cnVlIGlmIHlvdSBzaG91bGQgZW5jb2RlVVJJQ29tcG9uZW50KCkgdGhlIHZhbHVlcyAodHJ1ZSBieSBkZWZhdWx0KVxuICovXG5jb25zdCBidWlsZFVybFBhcmFtcyA9IChwYXJhbXMsIHNob3VsZEVuY29kZSA9IHRydWUpID0+IHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBlbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcbiAgICAgICAgbGV0IGVuY29kZWRWYWx1ZTtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaXRlbSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChzdHIgPT4ge1xuICAgICAgICAgICAgICAgIGVuY29kZWRWYWx1ZSA9IHNob3VsZEVuY29kZSA/IGVuY29kZVVSSUNvbXBvbmVudChzdHIpIDogc3RyO1xuICAgICAgICAgICAgICAgIGl0ZW0gKz0gYCR7a2V5fT0ke2VuY29kZWRWYWx1ZX0mYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbGFzdCBjaGFyYWN0ZXIgd2lsbCBhbHdheXMgYmUgXCImXCIgc28gc2xpY2UgaXQgb2ZmXG4gICAgICAgICAgICBpdGVtLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kZWRWYWx1ZSA9IHNob3VsZEVuY29kZSA/IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGl0ZW0gPSBgJHtrZXl9PSR7ZW5jb2RlZFZhbHVlfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2FjY3VtdWxhdG9yfSYke2l0ZW19YDtcbiAgICB9LCAnJyk7XG4gICAgLy8gUmVtb3ZlIGluaXRpYWwgXCImXCIgZnJvbSB0aGUgcmVkdWNlXG4gICAgcmV0dXJuIG91dHB1dC5zdWJzdHIoMSk7XG59O1xuLyoqXG4gKiBCdWlsZCB0aGUgUmVxdWVzdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIHRoZSBpbml0aWFsIHJlcXVlc3RcbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBIdHRwIHBsdWdpbiBvcHRpb25zXG4gKiBAcGFyYW0gZXh0cmEgQW55IGV4dHJhIFJlcXVlc3RJbml0IHZhbHVlc1xuICovXG5leHBvcnQgY29uc3QgYnVpbGRSZXF1ZXN0SW5pdCA9IChvcHRpb25zLCBleHRyYSA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB9LCBleHRyYSk7XG4gICAgLy8gR2V0IHRoZSBjb250ZW50LXR5cGVcbiAgICBjb25zdCBoZWFkZXJzID0gbm9ybWFsaXplSHR0cEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCB0eXBlID0gaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgLy8gSWYgYm9keSBpcyBhbHJlYWR5IGEgc3RyaW5nLCB0aGVuIHBhc3MgaXQgdGhyb3VnaCBhcy1pcy5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3V0cHV0LmJvZHkgPSBvcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHJlcXVlc3QgaW5pdGlhbGl6ZXJzIGJhc2VkIG9mZiBvZiBjb250ZW50LXR5cGVcbiAgICBlbHNlIGlmICh0eXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZGF0YSB8fCB7fSkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmJvZHkgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5pbmNsdWRlcygnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgb3B0aW9ucy5kYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5ib2R5ID0gZm9ybTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG91dHB1dC5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtdHlwZScpOyAvLyBjb250ZW50LXR5cGUgd2lsbCBiZSBzZXQgYnkgYHdpbmRvdy5mZXRjaGAgdG8gaW5jbHVkeSBib3VuZGFyeVxuICAgICAgICBvdXRwdXQuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvdXRwdXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLyoqXG4gKiBQZXJmb3JtIGFuIEh0dHAgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcXVlc3QgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RJbml0ID0gYnVpbGRSZXF1ZXN0SW5pdChvcHRpb25zLCBvcHRpb25zLndlYkZldGNoRXh0cmEpO1xuICAgIGNvbnN0IHVybFBhcmFtcyA9IGJ1aWxkVXJsUGFyYW1zKG9wdGlvbnMucGFyYW1zLCBvcHRpb25zLnNob3VsZEVuY29kZVVybFBhcmFtcyk7XG4gICAgY29uc3QgdXJsID0gdXJsUGFyYW1zID8gYCR7b3B0aW9ucy51cmx9PyR7dXJsUGFyYW1zfWAgOiBvcHRpb25zLnVybDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgcmVxdWVzdEluaXQpO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuICAgIC8vIERlZmF1bHQgdG8gJ3RleHQnIHJlc3BvbnNlVHlwZSBzbyBubyBwYXJzaW5nIGhhcHBlbnNcbiAgICBsZXQgeyByZXNwb25zZVR5cGUgPSAndGV4dCcgfSA9IHJlc3BvbnNlLm9rID8gb3B0aW9ucyA6IHt9O1xuICAgIC8vIElmIHRoZSByZXNwb25zZSBjb250ZW50LXR5cGUgaXMganNvbiwgZm9yY2UgdGhlIHJlc3BvbnNlIHRvIGJlIGpzb25cbiAgICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICByZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlYWRCbG9iQXNCYXNlNjQoYmxvYik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IGZldGNoIGhlYWRlcnMgdG8gQ2FwYWNpdG9yIEh0dHBIZWFkZXJzXG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgfTtcbn07XG4vKipcbiAqIFBlcmZvcm0gYW4gSHR0cCBHRVQgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IGdldCA9IGFzeW5jIChvcHRpb25zKSA9PiByZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbWV0aG9kOiAnR0VUJyB9KSk7XG4vKipcbiAqIFBlcmZvcm0gYW4gSHR0cCBQT1NUIHJlcXVlc3QgZ2l2ZW4gYSBzZXQgb2Ygb3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBwb3N0ID0gYXN5bmMgKG9wdGlvbnMpID0+IHJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtZXRob2Q6ICdQT1NUJyB9KSk7XG4vKipcbiAqIFBlcmZvcm0gYW4gSHR0cCBQVVQgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IHB1dCA9IGFzeW5jIChvcHRpb25zKSA9PiByZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbWV0aG9kOiAnUFVUJyB9KSk7XG4vKipcbiAqIFBlcmZvcm0gYW4gSHR0cCBQQVRDSCByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgcGF0Y2ggPSBhc3luYyAob3B0aW9ucykgPT4gcmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1ldGhvZDogJ1BBVENIJyB9KSk7XG4vKipcbiAqIFBlcmZvcm0gYW4gSHR0cCBERUxFVEUgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbCA9IGFzeW5jIChvcHRpb25zKSA9PiByZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbWV0aG9kOiAnREVMRVRFJyB9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LmpzLm1hcCIsImltcG9ydCB7IFdlYlBsdWdpbiB9IGZyb20gJ0BjYXBhY2l0b3IvY29yZSc7XG5pbXBvcnQgKiBhcyBDb29raWUgZnJvbSAnLi9jb29raWUnO1xuaW1wb3J0ICogYXMgUmVxdWVzdCBmcm9tICcuL3JlcXVlc3QnO1xuZXhwb3J0IGNsYXNzIEh0dHBXZWIgZXh0ZW5kcyBXZWJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhbiBIdHRwIHJlcXVlc3QgZ2l2ZW4gYSBzZXQgb2Ygb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IGFzeW5jIChvcHRpb25zKSA9PiBSZXF1ZXN0LnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGFuIEh0dHAgR0VUIHJlcXVlc3QgZ2l2ZW4gYSBzZXQgb2Ygb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0ID0gYXN5bmMgKG9wdGlvbnMpID0+IFJlcXVlc3QuZ2V0KG9wdGlvbnMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhbiBIdHRwIFBPU1QgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3N0ID0gYXN5bmMgKG9wdGlvbnMpID0+IFJlcXVlc3QucG9zdChvcHRpb25zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gYW4gSHR0cCBQVVQgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdXQgPSBhc3luYyAob3B0aW9ucykgPT4gUmVxdWVzdC5wdXQob3B0aW9ucyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGFuIEh0dHAgUEFUQ0ggcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXRjaCA9IGFzeW5jIChvcHRpb25zKSA9PiBSZXF1ZXN0LnBhdGNoKG9wdGlvbnMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhbiBIdHRwIERFTEVURSByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbCA9IGFzeW5jIChvcHRpb25zKSA9PiBSZXF1ZXN0LmRlbChvcHRpb25zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYWxsIEh0dHBDb29raWVzIGFzIGEgTWFwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldENvb2tpZXNNYXAgPSBhc3luYyAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29va2llcyA9IENvb2tpZS5nZXRDb29raWVzKCk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbY29va2llLmtleV0gPSBjb29raWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFsbCBIdHRwQ29va2llcyBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgdmFsdWVzIGFzIGFuIEh0dHBDb29raWVbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDb29raWVzID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgY29va2llcyA9IENvb2tpZS5nZXRDb29raWVzKCk7XG4gICAgICAgICAgICByZXR1cm4geyBjb29raWVzIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSBjb29raWVcbiAgICAgICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q29va2llID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSwgZXhwaXJlcyA9ICcnLCBwYXRoID0gJycgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBDb29raWUuc2V0Q29va2llKGtleSwgdmFsdWUsIHsgZXhwaXJlcywgcGF0aCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYWxsIGNvb2tpZSB2YWx1ZXMgdW5sZXNzIGEga2V5IGlzIHNwZWNpZmllZCwgdGhlbiByZXR1cm4gb25seSB0aGF0IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgY29va2llIHZhbHVlIHRvIGdldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDb29raWUgPSBhc3luYyAob3B0aW9ucykgPT4gQ29va2llLmdldENvb2tpZShvcHRpb25zLmtleSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIGEgY29va2llIGdpdmVuIGEga2V5XG4gICAgICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgY29va2llIHRvIGRlbGV0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGVDb29raWUgPSBhc3luYyAob3B0aW9ucykgPT4gQ29va2llLmRlbGV0ZUNvb2tpZShvcHRpb25zLmtleSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgb3V0IGNvb2tpZXMgYnkgc2V0dGluZyB0aGVtIHRvIGV4cGlyZSBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhckNvb2tpZXMgPSBhc3luYyAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgb3B0aW9ucykgPT4gQ29va2llLmNsZWFyQ29va2llcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIG91dCBjb29raWVzIGJ5IHNldHRpbmcgdGhlbSB0byBleHBpcmUgaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJBbGxDb29raWVzID0gYXN5bmMgKCkgPT4gQ29va2llLmNsZWFyQ29va2llcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkcyBhIGZpbGUgdGhyb3VnaCBhIFBPU1QgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUT0RPXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwbG9hZEZpbGUgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChvcHRpb25zLm5hbWUsIG9wdGlvbnMuYmxvYiB8fCAndW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGJvZHk6IGZvcm1EYXRhLCBtZXRob2Q6ICdQT1NUJyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QoZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvd25sb2FkcyBhIGZpbGVcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgVE9ET1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb3dubG9hZEZpbGUgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluaXQgPSBSZXF1ZXN0LmJ1aWxkUmVxdWVzdEluaXQob3B0aW9ucywgb3B0aW9ucy53ZWJGZXRjaEV4dHJhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gob3B0aW9ucy51cmwsIHJlcXVlc3RJbml0KTtcbiAgICAgICAgICAgIGxldCBibG9iO1xuICAgICAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByb2dyZXNzKSlcbiAgICAgICAgICAgICAgICBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgZWxzZSBpZiAoIShyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuYm9keSkpXG4gICAgICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGxldCBieXRlcyA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSB8fCAnMCcsIDEwKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzICs9ICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUubGVuZ3RoKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRE9XTkxPQUQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoJ3Byb2dyZXNzJywgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGFsbENodW5rcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGFsbENodW5rcy5zZXQoY2h1bmssIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9iID0gbmV3IEJsb2IoW2FsbENodW5rcy5idWZmZXJdLCB7IHR5cGU6IGNvbnRlbnRUeXBlIHx8IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmxvYixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLmpzLm1hcCJdLCJuYW1lcyI6WyJoZWFkZXJzIiwiUmVxdWVzdC5yZXF1ZXN0IiwiUmVxdWVzdC5nZXQiLCJSZXF1ZXN0LnBvc3QiLCJSZXF1ZXN0LnB1dCIsIlJlcXVlc3QucGF0Y2giLCJSZXF1ZXN0LmRlbCIsIkNvb2tpZS5nZXRDb29raWVzIiwiQ29va2llLnNldENvb2tpZSIsIkNvb2tpZS5nZXRDb29raWUiLCJDb29raWUuZGVsZXRlQ29va2llIiwiQ29va2llLmNsZWFyQ29va2llcyIsIlJlcXVlc3QuYnVpbGRSZXF1ZXN0SW5pdCJdLCJtYXBwaW5ncyI6IjtBQUlPLE1BQU0sbUJBQW1CLE9BQU8sU0FBUyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDN0UsUUFBTSxTQUFTLElBQUk7QUFDbkIsU0FBTyxTQUFTLE1BQU07QUFDbEIsVUFBTSxlQUFlLE9BQU87QUFDNUIsVUFBTSwwQkFBMEIsYUFBYSxPQUFPLGFBQWEsUUFBUSxHQUFHLElBQUksQ0FBQztBQUNqRixZQUFRLHVCQUF1QjtBQUFBLEVBQ3ZDO0FBQ0ksU0FBTyxVQUFVLENBQUMsVUFBVSxP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
